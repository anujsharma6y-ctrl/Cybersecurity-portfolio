import os
import requests
import json
import logging
import re
from datetime import datetime

# Terminal Colors
CYAN = "\033[96m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
RED = "\033[91m"
BOLD = "\033[1m"
RESET = "\033[0m"

logging.basicConfig(filename='threat_intel.log', level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')

class ThreatIntelSuite:
    def __init__(self):
        print(f"{CYAN}{BOLD}=== Vigilance Threat Intelligence & Automation Suite ==={RESET}")

    # 1. Credential Leak Scanner (Local Pattern Matching)
    def credential_leak_scanner(self, directory="."):
        print(f"\n{YELLOW}[+] Scanning for leaked credentials in scripts...{RESET}")
        # Patterns for API Keys, Passwords, and Secret Tokens
        patterns = {
            "AWS Key": r"AKIA[0-9A-Z]{16}",
            "Generic Secret": r"secret_?[a-zA-Z0-9]+",
            "API Token": r"api[_-]?key[_-]?[a-zA-Z0-9]+"
        }
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith(('.py', '.env', '.json', '.txt')):
                    with open(os.path.join(root, file), 'r', errors='ignore') as f:
                        content = f.read()
                        for name, pattern in patterns.items():
                            if re.search(pattern, content, re.IGNORECASE):
                                print(f"{RED}[!] ALERT: {name} found in {file}{RESET}")
                                logging.warning(f"Credential leak found: {name} in {file}")

    # 2. Threat Intelligence Feed Collector (Simulated API Call)
    def fetch_threat_feeds(self):
        print(f"\n{YELLOW}[+] Fetching Latest Threat Intelligence Feeds...{RESET}")
        # In real-world, you'd use APIs like OTX AlienVault or AbuseIPDB
        mock_feed = [
            {"ip": "192.168.1.50", "threat": "Botnet C2"},
            {"ip": "45.12.32.11", "threat": "Known Ransomware Distributor"}
        ]
        for item in mock_feed:
            print(f"{CYAN}[*] Intel Received: IP {item['ip']} is tagged as {item['threat']}{RESET}")
            logging.info(f"Threat Intel Sync: {item['ip']} - {item['threat']}")

    # 3. Incident Response Playbook Automator (Containment Logic)
    def run_ir_playbook(self, threat_type):
        print(f"\n{YELLOW}[+] Executing Incident Response Playbook: {threat_type}{RESET}")
        playbooks = {
            "ransomware": ["Isolate Network", "Freeze Backup Access", "Initiate Forensic Snapshots"],
            "brute_force": ["Block Source IP", "Force Password Reset", "Enable MFA"],
            "leak": ["Revoke API Tokens", "Audit Access Logs", "Update Environment Variables"]
        }
        
        steps = playbooks.get(threat_type.lower(), ["Notify Admin", "Investigate Logs"])
        for i, step in enumerate(steps, 1):
            time_stamp = datetime.now().strftime("%H:%M:%S")
            print(f"{GREEN}[Step {i}] {time_stamp} - ACTION: {step}{RESET}")
            logging.info(f"IR Action Taken: {step}")

    # 4. Security Audit Checklist Tool
    def security_audit_check(self):
        print(f"\n{YELLOW}[+] Running System Security Audit Checklist...{RESET}")
        checklist = {
            "Root Login Disabled": os.path.exists("/etc/ssh/sshd_config"), # Simplified check
            "Firewall Active": os.system("ufw status > /dev/null 2>&1") == 0,
            "Updates Pending": False # Placeholder
        }
        for item, status in checklist.items():
            result = f"{GREEN}[PASS]{RESET}" if status else f"{RED}[FAIL]{RESET}"
            print(f"[*] {item}: {result}")

if __name__ == "__main__":
    suite = ThreatIntelSuite()
    
    # Execution Sequence
    suite.fetch_threat_feeds()
    suite.credential_leak_scanner()
    suite.security_audit_check()
    
    # Simulate an automated response to a detected leak
    suite.run_ir_playbook("leak")

    print(f"\n{CYAN}--- Intelligence Sync & Automation Cycle Complete ---{RESET}")